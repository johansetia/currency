package currency

import (
	"encoding/json"
	"errors"
	"fmt"
)

// url is the URL that will be implemented
const url = "http://data.fixer.io/api/"

// Parser is used to store costom data that will be generated by function after.
type Parser struct {
	base   string
	secret string
}

// Fluctuation default variable is used to set a Time function to choose
var Fluctuation = "fluc"

// TimeSeries default variable is used to set a Time function to choose
var TimeSeries = "ts"

// New is used to make an object that will be used after.
func New(secret string) *Parser {
	parser := new(Parser)
	parser.secret = "?access_key=" + secret
	return parser
}

// NewSymbol is used to find a symbol to be filled when you will change.
func (p *Parser) NewSymbol() (Symbol, error) {
	var temp Symbol
	p.base = url + "symbols" + p.secret
	resp, err := p.get()
	if err != nil {
		return temp, err
	}
	defer resp.Close()
	err = json.NewDecoder(resp).Decode(&temp)
	if err != nil {
		return temp, errDecode
	}
	if temp.Status == false {
		return temp, errServer
	}
	return temp, nil
}

// SetBase  is supported on your subscription plan,
// you can change the currency to which your output currency rates
// are relative to by appending the base parameter to your API
// request URL and setting it to the three-letter code of your preferred base currency.
func (p *Parser) SetBase(base string) (SetBase, error) {
	var temp SetBase
	p.base = url + "latest" + p.secret + "&base=" + base
	resp, err := p.get()
	if err != nil {
		return temp, err
	}
	defer resp.Close()
	err = json.NewDecoder(resp).Decode(&temp)
	if err != nil {
		return temp, errDecode
	}
	if temp.Status == false {
		return temp, errServer
	}
	return temp, nil
}

// History rates are available for most currencies all the way back to the year of 1999.
// You can query the Fixer API for historical rates by appending a date (format YYYY-MM-DD) to the base URL.
func (p *Parser) History(date, base string, symbols ...string) (History, error) {
	var temp History
	rURL, err := toString(symbols...)
	if err != nil {
		return temp, err
	}
	p.base = url + date + p.secret + "&base=" + base + "&symbols=" + rURL
	resp, err := p.get()
	if err != nil {
		return temp, err
	}
	defer resp.Close()
	err = json.NewDecoder(resp).Decode(&temp)
	if err != nil {
		return temp, errDecode
	}
	if temp.Status == false {
		return temp, errServer
	}
	return temp, nil
}

// Convert can be used to convert any amount from one currency to another.
// In order to convert currencies, please use the API's convert endpoint, append the
// from and to parameters and set them to your preferred base and target currency codes.
func (p *Parser) Convert(from, to string, amount float32) (Convert, error) {
	var temp Convert
	p.base = string(url + "convert" + p.secret + "&from=" + from + "&to=" + to + "&amount=" + fmt.Sprintf("%.3f", amount))
	resp, err := p.get()
	if err != nil {
		return temp, err
	}
	defer resp.Close()
	err = json.NewDecoder(resp).Decode(&temp)
	if err != nil {
		return temp, errDecode
	}
	if temp.Status == false {
		return temp, errServer
	}
	return temp, nil
}

// LatestRates will return real-time exchange rate data updated
// every 60 minutes, every 10 minutes or every 60 seconds.
func (p *Parser) LatestRates(base string, symbols ...string) (SetBase, error) {
	var temp SetBase
	rURL, err := toString(symbols...)
	if err != nil {
		return temp, err
	}

	p.base = url + "latest" + p.secret + "&base=" + base + "&symbols=" + rURL
	resp, err := p.get()
	if err != nil {
		return temp, err
	}
	defer resp.Close()
	err = json.NewDecoder(resp).Decode(&temp)
	if err != nil {
		return temp, errDecode
	}
	if temp.Status == false {
		return temp, errServer
	}
	return temp, nil
}

// Time : when you pass a Fluctuation variable you will be able to
// retrieve information about how currencies fluctuate on a day-to-day basis.
// To use this feature, simply append a startDate and endDate.
// and when you pass a Timeseries variable you will get a time series by currency.
func (p *Parser) Time(typ, startDate, endDate string) (FluctOrTs, error) {
	var temp FluctOrTs
	if typ == Fluctuation {
		typ = "fluctuation"
	} else if typ == TimeSeries {
		typ = "timeseries"
	} else {
		return temp, errors.New("Error missmatch type")
	}
	p.base = url + typ + p.secret + "&start_date=" + startDate + "&end_date=" + endDate

	resp, err := p.get()
	if err != nil {
		return temp, err
	}
	defer resp.Close()
	err = json.NewDecoder(resp).Decode(&temp)
	if err != nil {
		return temp, errDecode
	}
	if temp.Status == false {
		return temp, errServer
	}
	return temp, nil
}
